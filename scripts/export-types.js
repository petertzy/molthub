#!/usr/bin/env node

/**
 * TypeScript Type Definitions Exporter
 * 
 * This script generates TypeScript type definitions from OpenAPI specification
 * for use in client applications.
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

const OPENAPI_FILE = path.join(__dirname, '../openapi.yaml');
const OUTPUT_DIR = path.join(__dirname, '../types');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'api.d.ts');

/**
 * Convert OpenAPI type to TypeScript type
 * @param {Object} schema - OpenAPI schema
 * @param {Object} components - OpenAPI components for resolving references
 * @returns {string} TypeScript type string
 */
function schemaToTypeScript(schema, components) {
  if (!schema) return 'any';
  
  // Handle references
  if (schema.$ref) {
    const refName = schema.$ref.split('/').pop();
    return refName;
  }
  
  // Handle arrays
  if (schema.type === 'array') {
    const itemType = schemaToTypeScript(schema.items, components);
    return `${itemType}[]`;
  }
  
  // Handle objects with properties
  if (schema.type === 'object' && schema.properties) {
    const props = Object.entries(schema.properties).map(([key, prop]) => {
      const optional = schema.required && schema.required.includes(key) ? '' : '?';
      const type = schemaToTypeScript(prop, components);
      const description = prop.description ? `\n  /** ${prop.description} */` : '';
      return `${description}\n  ${key}${optional}: ${type};`;
    }).join('\n  ');
    return `{\n  ${props}\n}`;
  }
  
  // Handle enums
  if (schema.enum) {
    return schema.enum.map(v => `'${v}'`).join(' | ');
  }
  
  // Handle basic types
  const typeMap = {
    string: 'string',
    number: 'number',
    integer: 'number',
    boolean: 'boolean',
    object: 'Record<string, any>',
    array: 'any[]'
  };
  
  // Handle nullable
  const baseType = typeMap[schema.type] || 'any';
  return schema.nullable ? `${baseType} | null` : baseType;
}

/**
 * Generate TypeScript interface from schema
 * @param {string} name - Interface name
 * @param {Object} schema - OpenAPI schema
 * @param {Object} components - OpenAPI components
 * @returns {string} TypeScript interface definition
 */
function generateInterface(name, schema, components) {
  let output = '';
  
  // Add description as comment
  if (schema.description) {
    output += `/**\n * ${schema.description}\n */\n`;
  }
  
  output += `export interface ${name} `;
  
  if (schema.type === 'object' && schema.properties) {
    output += schemaToTypeScript(schema, components);
  } else {
    // For non-object schemas, create a type alias instead
    const type = schemaToTypeScript(schema, components);
    output = output.replace(`export interface ${name} `, `export type ${name} = ${type};`);
    return output;
  }
  
  return output;
}

/**
 * Generate API request/response types
 * @param {Object} spec - OpenAPI specification
 * @returns {string} TypeScript definitions
 */
function generateAPITypes(spec) {
  let output = '// Auto-generated TypeScript definitions from OpenAPI specification\n';
  output += '// Do not edit this file manually\n\n';
  
  const { components, paths } = spec;
  
  if (components && components.schemas) {
    output += '// ========== Data Models ==========\n\n';
    
    Object.entries(components.schemas).forEach(([name, schema]) => {
      output += generateInterface(name, schema, components);
      output += '\n\n';
    });
  }
  
  // Generate request/response types for each endpoint
  if (paths) {
    output += '// ========== API Endpoints ==========\n\n';
    
    Object.entries(paths).forEach(([path, methods]) => {
      Object.entries(methods).forEach(([method, operation]) => {
        if (!operation.operationId) return;
        
        const operationName = operation.operationId.charAt(0).toUpperCase() + operation.operationId.slice(1);
        
        // Request type
        if (operation.requestBody) {
          const content = operation.requestBody.content['application/json'];
          if (content && content.schema) {
            output += `/**\n * Request body for ${operationName}\n */\n`;
            output += `export type ${operationName}Request = `;
            output += schemaToTypeScript(content.schema, components);
            output += ';\n\n';
          }
        }
        
        // Parameters type
        if (operation.parameters && operation.parameters.length > 0) {
          output += `/**\n * Parameters for ${operationName}\n */\n`;
          output += `export interface ${operationName}Params {\n`;
          operation.parameters.forEach(param => {
            const optional = param.required ? '' : '?';
            const hasSchema = param.schema !== undefined;
            if (!hasSchema) {
              console.warn(`‚ö†Ô∏è  Warning: Parameter '${param.name}' in ${operationName} has no schema, defaulting to string`);
            }
            const type = schemaToTypeScript(param.schema || { type: 'string' }, components);
            if (param.description) {
              output += `  /** ${param.description} */\n`;
            }
            // Quote parameter names with special characters
            const paramName = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(param.name) ? param.name : `'${param.name}'`;
            output += `  ${paramName}${optional}: ${type};\n`;
          });
          output += '}\n\n';
        }
        
        // Response type
        const successResponse = operation.responses['200'] || operation.responses['201'];
        if (successResponse) {
          const content = successResponse.content?.['application/json'];
          if (content && content.schema) {
            output += `/**\n * Response for ${operationName}\n */\n`;
            output += `export type ${operationName}Response = `;
            output += schemaToTypeScript(content.schema, components);
            output += ';\n\n';
          }
        }
      });
    });
  }
  
  // Add common types
  output += '// ========== Common Types ==========\n\n';
  output += `/**\n * Standard API response wrapper\n */\n`;
  output += `export interface APIResponse<T = any> {\n`;
  output += `  success: boolean;\n`;
  output += `  data?: T;\n`;
  output += `  error?: {\n`;
  output += `    code: string;\n`;
  output += `    message: string;\n`;
  output += `    details?: any;\n`;
  output += `  };\n`;
  output += `  meta?: PaginationMeta;\n`;
  output += `}\n\n`;
  
  return output;
}

/**
 * Main function
 */
function main() {
  console.log('üöÄ Generating TypeScript type definitions from OpenAPI spec...\n');
  
  // Load OpenAPI spec
  if (!fs.existsSync(OPENAPI_FILE)) {
    console.error(`‚ùå Error: OpenAPI file not found: ${OPENAPI_FILE}`);
    process.exit(1);
  }
  
  const fileContents = fs.readFileSync(OPENAPI_FILE, 'utf8');
  const spec = yaml.load(fileContents);
  console.log('‚úÖ OpenAPI specification loaded\n');
  
  // Create output directory
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    console.log(`‚úÖ Created output directory: ${OUTPUT_DIR}\n`);
  }
  
  // Generate TypeScript definitions
  const typeDefinitions = generateAPITypes(spec);
  
  // Write to file
  fs.writeFileSync(OUTPUT_FILE, typeDefinitions, 'utf8');
  console.log(`‚úÖ TypeScript definitions generated: ${OUTPUT_FILE}`);
  
  // Calculate stats
  const interfaceCount = (typeDefinitions.match(/export interface/g) || []).length;
  const typeCount = (typeDefinitions.match(/export type/g) || []).length;
  
  console.log(`\nüìä Summary:`);
  console.log(`   - Interfaces: ${interfaceCount}`);
  console.log(`   - Type aliases: ${typeCount}`);
  console.log(`   - Total lines: ${typeDefinitions.split('\n').length}`);
  
  console.log(`\nüí° Usage in your TypeScript project:`);
  console.log(`   import { Agent, Post, Comment } from './types/api';`);
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { schemaToTypeScript, generateInterface, generateAPITypes };
